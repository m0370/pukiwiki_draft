**PukiWikiに自動保存機能を追加した話**

ぼくが趣味で運営しているPukiWikiサイトに、編集中の内容を自動的に保存してくれる機能を追加しました。以前から下書き保存機能は実装していたのですが、手動で保存ボタンを押さないといけなかったわけです。長い文章を書いていて、ブラウザがクラッシュして全部消えた経験は誰にでもあるでしょう。そういった事故を防ぐため、30秒ごとに自動的に下書きとして保存してくれる機能を作ってみました。

実装してみるといくつか面白い問題にぶつかったので、ここに記録しておきます。

## 背景

そもそもPukiWikiには標準で下書き保存機能がありません。編集中に誤ってブラウザを閉じてしまったり、セッションがタイムアウトしたりすると、それまで入力していた内容がすべて失われます。これはかなり辛いので、以前に下書き保存機能を自作していました。この機能自体はv1.1.0で一応動くようになっていて、手動で「下書き保存」ボタンを押せば内容が保存されるわけです。

しかし人間というのは保存を忘れるものです。特に長文を書いているときほど、途中で保存することを忘れがちです。そこで自動保存機能があれば便利だろうと思い、実装することにしました。WordやGoogleドキュメントなら当たり前にある機能ですが、PukiWikiのようなレガシーなシステムに追加するのは意外と面倒でした。

## FormDataの送信で最初につまずいた

JavaScriptで自動保存を実装するとき、最初は単純に考えていました。編集フォーム全体を取得して、Fetch APIでサーバーに送ればいいだろうと。しかし、ここで問題が起きました。

PukiWikiの編集フォームには「プレビュー」「更新」「下書き保存」という3つのボタンがあります。`plugin/edit.inc.php`というファイルで、どのボタンが押されたかを判定して処理を分岐しているわけです。最初の実装では`new FormData(form)`でフォーム全体をコピーしていたのですが、これだと他のボタンの値も一緒に送信されてしまって、サーバー側の処理分岐がうまく動かないことがありました。

結局、必要最小限のフィールドだけを手動で追加することにしました。`cmd`、`page`、`msg`、`digest`、`ticket`、`draft_save`の6つだけです。こうすることで、確実に下書き保存処理が実行されるようになりました。FormDataというのは便利なAPIですが、全部自動でやってくれるわけではないんですね。

## 既存の下書きを上書きしてしまう問題

自動保存を実装してテストしていると、別の問題に気づきました。ページを開いたときに既存の下書きが存在すると、画面に通知が表示されます。ユーザーはその通知を見て「下書きを読み込む」か「無視する」かを選ぶわけです。しかし自動保存が有効になっていると、ユーザーが何も選択していないうちに30秒経過して、既存の下書きが上書きされてしまいます。

これでは困るので、既存下書き通知が表示されている間は自動保存を停止するようにしました。具体的には`#draft_notice`というIDを持つ要素が存在するかチェックして、存在する場合は自動保存をスキップします。ユーザーが下書きを読み込むか、通知を閉じるまで、自動保存は実行されません。

こういった細かい配慮をしないと、便利な機能のはずが逆に迷惑な機能になってしまいます。

## HTML構造が壊れる問題

実装の途中で、JavaScriptの`<script>`タグを`lib/html.php`の途中に挿入していたら、HTMLの構造が壊れてしまいました。`main.js`が正しく読み込まれなくなったり、CSSのスタイルが適用されなくなったりして、何が起きているのか最初はわかりませんでした。

よく調べてみると、`<script>`タグを挿入した位置が悪かったようです。`</div>`タグの前に挿入していたため、HTMLの階層が崩れていました。`</div>`タグの後に移動したら、すべて正常に動くようになりました。PHPで動的にHTMLを生成するときは、こういった基本的なことにも注意が必要です。

## 保存中に再度保存が走る問題

自動保存が実行中に、再度30秒のタイマーが発火すると、サーバーへのリクエストが重複してしまいます。これを防ぐために`isSaving`というフラグを導入しました。保存を開始するときにフラグを立てて、完了したら下ろします。フラグが立っている間は新たな自動保存を開始しません。

Promise.finally()を使って、成功しても失敗してもフラグを下ろすようにしています。このあたりはJavaScriptの非同期処理の基本ですが、忘れるとバグの温床になります。

## 国際化対応

PukiWikiは日本語と英語の両方をサポートしています。自動保存機能のメッセージも、当然ながら両言語に対応する必要がありました。JavaScriptから直接メッセージをハードコードすると、言語切り替えができません。

そこでPHP側で言語ファイルからメッセージを読み込んで、`json_encode()`でJavaScriptに渡すようにしました。`lib/html.php`で`window.AUTOSAVE_MESSAGES`というグローバル変数を設定して、JavaScript側ではそれを参照します。この方法なら、ユーザーの言語設定に応じて適切なメッセージが表示されます。

PHP 8.4では`JSON_UNESCAPED_UNICODE`を指定しないと日本語が文字化けすることがあるので、そのあたりも注意しました。

## トースト通知の実装

保存が成功したとき、画面右上にトースト通知を表示するようにしました。「自動保存しました: 14:32」といったメッセージが3秒間表示されて、スライドインアニメーションで登場し、スライドアウトで消えます。

CSSアニメーションはJavaScriptで動的に追加しています。`@keyframes`を使ったアニメーション定義を`<style>`タグで挿入して、トースト要素に適用します。既存のトーストがあれば削除してから新しいものを表示するようにして、通知が重ならないようにしました。

このあたりのUI実装は、ライブラリを使えば簡単なんでしょうが、今回はVanilla JavaScriptで書いています。PukiWikiにjQueryを導入するのも大げさですし、依存関係を増やしたくなかったので。

## 保存間隔の調整

当初は60秒間隔で実装していました。しかし実際に使ってみると、60秒は少し長く感じました。入力している内容が結構たまってから保存されるので、不安になります。そこで30秒に短縮しました。

30秒という間隔は、サーバー負荷とユーザーの安心感のバランスを考えた結果です。あまり短くしすぎるとサーバーへのリクエストが増えますし、長すぎるとユーザーが不安になります。30秒なら実用的だろうと判断しました。

## セキュリティ対策

自動保存でも、既存の下書き保存と同じセキュリティ対策を実装しています。CSRFトークンとして`ticket`フィールドをリクエストに含めて、サーバー側で検証します。また`check_editable()`でページ編集権限も確認します。出力時は`htmlsc()`でエスケープしています。

このあたりの対策は、既存のPukiWikiのコードを参考にしました。`plugin/edit.inc.php`や`plugin/freeze.inc.php`を読むと、CSRF対策の実装例が見つかります。車輪の再発明をする必要はありません。

## anameプラグインの問題

実装中に、編集画面で`&aname(...)`という文字列がそのまま表示される問題に気づきました。最初は自動保存機能が原因かと思ったのですが、調べてみるとPukiWikiコアの問題でした。`plugin/aname.inc.php`が実装されていないため、aname記法がパースされずに生のまま表示されていたわけです。

これは自動保存機能とは無関係なので、今回のスコープ外としました。将来的にanameプラグインを実装するかもしれませんが、それは別の話です。

## 動作環境とブラウザ互換性

実装ではFetch APIとPromise.finally()を使っているため、IE11は非サポートです。まあ2025年にIE11を使っている人はほとんどいないでしょうから、これは問題ないと判断しました。Chrome、Firefox、Safari、Edgeといったモダンブラウザでは問題なく動きます。

PHP側はPHP 8.3と8.4で動作確認しています。将来的にPHP 9.0が出たときにも対応できるよう、非推奨機能は避けるようにしました。

## 実装してみての感想

自動保存機能は一見単純に思えますが、実装してみるといくつもの落とし穴がありました。FormDataの挙動、既存データの保護、HTML構造、重複実行防止、国際化対応など、考えることは意外と多かったです。

それでも、実際に使ってみると便利です。長い記事を書いているときに、30秒ごとに自動保存されているという安心感があります。ブラウザがクラッシュしても、最悪30秒分のデータしか失われません。

今後の改善としては、保存間隔をユーザーがカスタマイズできるようにしたり、Service Workerを使ったオフライン対応などが考えられます。ただ、現時点では必要十分な機能が実装できたと思います。

実装の詳細は`AUTOSAVE_IMPLEMENTATION.md`に記録してあります。また、GitHubリポジトリ（https://github.com/m0370/pukiwiki_draft）で公開しているので、興味がある方は見てみてください。

## 使用したツール

この実装は、Anthropic社のClaude Code（Claude Sonnet 4.5）を使って進めました。コードレビューや問題点の指摘、セキュリティチェックなど、かなりの部分をAIに手伝ってもらいました。特にPukiWikiのような古いコードベースを理解して、適切な実装パターンを提案してくれたのは助かりました。

ただし、最終的な判断や調整は人間がやる必要があります。AIが提案したコードをそのまま使うのではなく、実際に動かしてテストして、問題があれば修正していく。そういった地道な作業は変わりません。
